1. 역할 분담 (Master - Slave)
Master (ESP32_Master_SPI): 두뇌 역할을 합니다. 사용자의 입력을 받거나 일정한 스케줄에 따라 명령(w, x, 1 등)을 생성하여 보냅니다.
Slave (MotorDrive_Mega): 손발 역할을 합니다. 마스터가 보내주는 명령을 SPI 인터럽트로 실시간 수신하고, 그 명령에 따라 모터를 실제로 구동합니다.
2. 패킷 프로토콜 (데이터의 규칙)
두 보드는 데이터를 주고받을 때 < 와 > 라는 괄호를 사용하기로 약속했습니다.

형식: < [한 바이트 명령] > (총 3바이트 패킷)
이유: 전기적 노이즈로 데이터가 한두 바이트 튀더라도, 메가 보드가 <를 만나는 순간 "여기서부터 새로 시작하는구나!" 하고 다시 동기화를 맞출 수 있게 설계되었습니다.

3. 세이프티 워치독 (Safety Watchdog)
이 시스템의 가장 중요한 안전 장치입니다.

마스터(ESP32): 사용자가 아무것도 입력하지 않아도 500ms마다 자동적으로 정지(x) 패킷을 보냅니다. (나 살아있어! 라는 하트비트 기능)
슬레이브(Mega): 마지막 통신 이후 700ms 이상 소식이 없으면 "통신이 끊겼다"고 판단하고 즉시 모터를 세웁니다. ([WATCHDOG] Communication LOST!)
결과: 통신선이 빠지거나 ESP32가 멈추더라도 로봇이 폭주하지 않고 즉시 멈춥니다.

4. 속도 최적화 (Synchronization)
속도 차이: ESP32는 240MHz로 매우 빠르고, 메가는 16MHz로 상대적으로 느립니다.
해결책: ESP32가 데이터를 보낼 때 각 바이트 사이에 30마이크로초(delayMicroseconds(30))의 휴식 시간을 줍니다. 이 짧은 시간이 메가 보드가 이전 바이트를 처리하고 다음 바이트를 받을 준비를 할 수 있게 해주는 핵심 열쇠입니다.
통신 과정 요약 (순서도)
ESP32: 사용자가 w(전진)를 입력하거나, 500ms 시간이 됨.
ESP32: SPI 선을 통해 < → (30us 대기) → w → (30us 대기) → > 순서로 보냄.
Mega: 인터럽트(ISR)가 발생하며 3바이트를 차례로 수집.
Mega: 패킷이 완성되면 cmdReceived 플래그를 세우고 lastPacketTime을 현재로 갱신 (워치독 안심시킴).
Mega: 
loop()
에서 'w' 명령을 확인하고 motor.forward() 실행.
만약 지금 통신이 안 된다면?
가장 먼저 확인해야 할 점은 물리적 연결입니다.

SS 핀: ESP32의 5번 핀이 메가의 53번 핀에 꽂혀 있는지 확인 (이게 서로 다르면 데이터가 안 들어옵니다).
GND: 두 보드의 GND가 한 선으로 연결되어 전위차가 없는지 확인.
전압 차이: ESP32(3.3V) 신호가 메가(5V)에 잘 전달되는지. (보통은 직접 연결해도 잘 되지만, 1MHz 미만 속도에서는 확실합니다.)
지금 코드는 소프트웨어적으로는 통신을 위한 가장 안정적인 로직이 적용되어 있는 상태입니다!

