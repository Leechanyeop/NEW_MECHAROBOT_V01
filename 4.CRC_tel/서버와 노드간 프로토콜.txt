프레임 규격 설계
목표: PC → ESP32(UDP) → Arduino(SPI) 흐름에서 작고 파싱이 빠른 이진 프레임 사용.
공통 규칙: 모든 페이로드는 CRC16으로 무결성 검사, 1바이트 시퀀스, 명령 타입 포함.
PC→ESP32 UDP 프레임 (권장)
[0]  Start byte      0xAA
[1]  Version         0x01
[2]  MsgType         1 byte  (0x01=CMD,0x02=PING,0x03=CONFIG)
[3]  Seq             1 byte
[4]  Len             1 byte  (payload 길이)
[5..N] Payload       Len bytes
[N+1..N+2] CRC16     2 bytes big-endian


ESP32→Arduino SPI 프레임
[0]  Start byte      0x55
[1]  Cmd             1 byte  (0x10=SET_SERVO,0x20=SET_PWM,0x30=STATUS_REQ)
[2]  Seq             1 byte
[3]  Len             1 byte
[4..] Payload        Len bytes
[last-1..last] CRC16 2 bytes big-endian


ACK/응답 규약
- Arduino는 처리 후 ACK 프레임(Cmd=0xA0, Seq 동일, Len=1, payload=0x00 성공/0x01 실패)을 SPI로 반환.
- ESP32는 ACK 미수신 시 재전송(타임아웃 150 ms, 최대 3회).
- PC↔ESP32는 필요 시 동일한 시퀀스/ACK 메커니즘을 적용.

ESP32 코드 개요 UDP 수신 → SPI 전송
- 기능: UDP로 프레임 수신 → 검증(CRC/Start/Len) → 내부 로직 → SPI로 Arduino에 전송 → ACK 대기 → PC에 상태 응답.
- 주의: SPI는 SPI.begin(SCLK, MISO, MOSI, SS) 형태로 초기화. CS는 직접 제어.
// ESP32_UDP_SPI.ino
#include <WiFi.h>
#include <WiFiUdp.h>
#include <SPI.h>

const char* ssid = "YOUR_SSID";
const char* password = "YOUR_PASS";
WiFiUDP udp;
const unsigned int localPort = 8888;

#define SS_PIN 5
#define SPI_SCLK 18
#define SPI_MISO 19
#define SPI_MOSI 23

uint8_t udpBuf[256];

uint16_t crc16(const uint8_t *data, size_t len) {
  uint16_t crc = 0xFFFF;
  for (size_t i=0;i<len;i++) {
    crc ^= (uint16_t)data[i] << 8;
    for (int j=0;j<8;j++) {
      if (crc & 0x8000) crc = (crc << 1) ^ 0x1021;
      else crc <<= 1;
    }
  }
  return crc;
}

void setup() {
  Serial.begin(115200);
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) { delay(500); Serial.print("."); }
  Serial.println("\nWiFi connected");
  Serial.print("ESP32 IP: "); Serial.println(WiFi.localIP());

  udp.begin(localPort);
  Serial.printf("UDP listening on %d\n", localPort);

  SPI.begin(SPI_SCLK, SPI_MISO, SPI_MOSI, SS_PIN);
  pinMode(SS_PIN, OUTPUT);
  digitalWrite(SS_PIN, HIGH);
}

bool validateUdpFrame(uint8_t *buf, int len, uint8_t &msgType, uint8_t &seq, uint8_t *&payload, uint8_t &payloadLen) {
  if (len < 6) return false;
  if (buf[0] != 0xAA) return false;
  if (buf[1] != 0x01) return false;
  msgType = buf[2];
  seq = buf[3];
  payloadLen = buf[4];
  if (5 + payloadLen + 2 != len) return false;
  payload = &buf[5];
  uint16_t recvCrc = (buf[5+payloadLen] << 8) | buf[5+payloadLen+1];
  uint16_t calc = crc16(buf, 5 + payloadLen);
  return recvCrc == calc;
}

bool spiTransferAndWaitAck(uint8_t *frame, size_t frameLen, uint8_t seq) {
  // CS LOW, transfer frame, then read ACK (simple synchronous exchange)
  digitalWrite(SS_PIN, LOW);
  for (size_t i=0;i<frameLen;i++) SPI.transfer(frame[i]);
  // read ACK frame header (assume fixed small ACK: Start(0x55), Cmd(0xA0), Seq, Len, payload, CRC)
  uint8_t ackBuf[8];
  for (int i=0;i<6;i++) ackBuf[i] = SPI.transfer(0x00);
  digitalWrite(SS_PIN, HIGH);

  // minimal validation
  if (ackBuf[0] != 0x55) return false;
  if (ackBuf[1] != 0xA0) return false;
  if (ackBuf[2] != seq) return false;
  // payload check omitted for brevity
  return true;
}

void loop() {
  int packetSize = udp.parsePacket();
  if (packetSize) {
    int len = udp.read(udpBuf, sizeof(udpBuf));
    uint8_t msgType, seq, *payload; uint8_t payloadLen;
    if (!validateUdpFrame(udpBuf, len, msgType, seq, payload, payloadLen)) {
      Serial.println("Invalid UDP frame");
      return;
    }
    Serial.printf("UDP MsgType %02X Seq %d Len %d\n", msgType, seq, payloadLen);

    // Build SPI frame from payload (example: Cmd = payload[0] or map msgType->Cmd)
    uint8_t spiFrame[64];
    size_t spiLen = 0;
    spiFrame[spiLen++] = 0x55;                // Start
    spiFrame[spiLen++] = payload[0];          // Cmd (예: payload 첫바이트)
    spiFrame[spiLen++] = seq;                 // Seq
    spiFrame[spiLen++] = payloadLen - 1;      // Len (payload에서 첫바이트 제외)
    for (int i=1;i<payloadLen;i++) spiFrame[spiLen++] = payload[i];
    uint16_t crc = crc16(spiFrame, spiLen);
    spiFrame[spiLen++] = (crc >> 8) & 0xFF;
    spiFrame[spiLen++] = crc & 0xFF;

    // ACK/재전송 루틴
    bool ok = false;
    for (int attempt=0; attempt<3 && !ok; attempt++) {
      ok = spiTransferAndWaitAck(spiFrame, spiLen, seq);
      if (!ok) delay(150);
    }

    // (선택) PC에 상태 응답 전송
    udp.beginPacket(udp.remoteIP(), udp.remotePort());
    if (ok) udp.print("ACK");
    else udp.print("NACK");
    udp.endPacket();
  }
}



Arduino UNO SPI Slave 파서 예제
- 기능: SPI 인터럽트로 바이트 수신 → 프레임 완성 시 CRC 검사 → 명령 실행 → ACK 반환.
- 주의: UNO는 SPI Slave로 동작 시 SPDR를 즉시 채워 응답 바이트를 준비해야 함.
// UNO_SPI_Slave.ino
#include <SPI.h>

volatile bool frameReady = false;
volatile uint8_t buf[64];
volatile uint8_t idx = 0;

uint16_t crc16(const uint8_t *data, size_t len) {
  uint16_t crc = 0xFFFF;
  for (size_t i=0;i<len;i++) {
    crc ^= (uint16_t)data[i] << 8;
    for (int j=0;j<8;j++) {
      if (crc & 0x8000) crc = (crc << 1) ^ 0x1021;
      else crc <<= 1;
    }
  }
  return crc;
}

ISR(SPI_STC_vect) {
  uint8_t c = SPDR; // 수신된 바이트
  buf[idx++] = c;
  // 즉시 응답 바이트 준비(기본 0x00)
  SPDR = 0x00;
  // 간단한 프레임 종료 조건: 최소 길이 넘고 CRC 위치 도달하면 표시
  if (idx >= 6) {
    // Start byte check
    if (buf[0] != 0x55) { idx = 0; return; }
    uint8_t len = buf[3];
    if (idx >= 4 + len + 2) {
      frameReady = true;
    }
  }
}

void setup() {
  Serial.begin(9600);
  pinMode(MISO, OUTPUT);
  SPCR |= _BV(SPE);  // SPI Enable (Slave)
  SPCR |= _BV(SPIE); // SPI Interrupt Enable
  idx = 0;
}

void loop() {
  if (frameReady) {
    noInterrupts();
    uint8_t localBuf[64];
    uint8_t localLen = idx;
    memcpy(localBuf, (const void*)buf, localLen);
    idx = 0;
    frameReady = false;
    interrupts();

    // Validate
    if (localBuf[0] != 0x55) { Serial.println("Bad start"); continue; }
    uint8_t cmd = localBuf[1];
    uint8_t seq = localBuf[2];
    uint8_t len = localBuf[3];
    uint16_t recvCrc = (localBuf[4+len] << 8) | localBuf[4+len+1];
    uint16_t calc = crc16(localBuf, 4 + len);
    if (recvCrc != calc) { Serial.println("CRC fail"); continue; }

    // 명령 처리 예: SET_SERVO (cmd 0x10), payload: [servoId, angle]
    if (cmd == 0x10 && len >= 2) {
      uint8_t id = localBuf[4];
      uint8_t angle = localBuf[5];
      Serial.print("Set servo "); Serial.print(id); Serial.print(" to "); Serial.println(angle);
      // 실제 서보 제어 코드 삽입
    }

    // ACK 준비 및 전송: SPI는 마스터가 클럭을 제공할 때만 전송되므로
    // 간단히 상태를 시리얼로 출력하고 SPDR에 다음 바이트를 채워둠
    // (ESP32가 추가로 클럭을 돌려 ACK를 읽어가도록 설계해야 함)
    // 여기서는 SPDR에 ACK 바이트를 미리 채움
    // 실제 ACK 프레임 전송은 마스터가 추가로 클럭을 제공할 때 읽혀짐
    // 예: SPDR = 0xA0; // 첫 응답 바이트
  }
}



PC 측 전송 예제 및 테스트 방법
- 권장: 개발 초기에는 Python 스크립트로 이진 프레임 생성 후 UDP 전송하여 테스트.
# send_udp_frame.py
import socket, struct, binascii

def crc16(data: bytes) -> int:
    crc = 0xFFFF
    for b in data:
        crc ^= b << 8
        for _ in range(8):
            if crc & 0x8000:
                crc = (crc << 1) ^ 0x1021
            else:
                crc <<= 1
            crc &= 0xFFFF
    return crc

udp_ip = "192.168.0.50"  # ESP32 IP
udp_port = 8888

# payload 예: Cmd=0x10 (SET_SERVO), servoId=1, angle=90
payload = bytes([0x10, 0x01, 90])
frame = bytearray()
frame += b'\xAA'            # Start
frame += b'\x01'            # Version
frame += b'\x01'            # MsgType CMD
frame += b'\x05'            # Seq
frame += bytes([len(payload)]) 
frame += payload
crc = crc16(frame[:5+len(payload)])
frame += struct.pack('>H', crc)

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.sendto(frame, (udp_ip, udp_port))
print("Sent", binascii.hexlify(frame))


- 테스트 순서
- ESP32 코드 업로드 후 시리얼로 IP 확인.
- PC에서 Python 스크립트 실행.
- ESP32 시리얼 로그에서 수신/전송 상태 확인.
- UNO 쪽 시리얼로 SPI 수신 로그 확인.

하드웨어·성능·안전 체크리스트
- 레벨 시프터: TXS0108E 또는 74LVC245 사용. MISO 라인(UNO→ESP32)은 특히 중요.
- SPI 클럭: 초기 1 MHz 권장. 안정화 후 2–4 MHz로 조정 가능.
- 전원 분리: 모터 전원은 별도 공급, GND는 공통 연결.
- 방화벽/네트워크: ESP32와 PC가 동일 서브넷인지 확인. UDP는 비신뢰성 프로토콜이므로 ACK/재전송 로직 필수.
- 안전 명령: EMERGENCY_STOP(우선 처리) 명령 타입을 별도로 정의.
