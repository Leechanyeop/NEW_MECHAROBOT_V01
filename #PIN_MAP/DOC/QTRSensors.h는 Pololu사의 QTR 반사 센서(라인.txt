QTRSensors.h는 Pololu사의 QTR 반사 센서(라인 센서) 어레이를 쉽게 제어하기 위한 라이브러리의 헤더 파일입니다. 이 라이브러리는 센서의 값을 읽고, 보정(Calibration)하고, 라인의 위치를 계산하는 기능을 제공합니다.

QTR_Test.ino
 코드에서 사용된 방식(버전 4.0 이상)을 기준으로 기능별 상세 설명을 드리겠습니다.

1. 설정 및 초기화 (Configuration)
이 섹션의 함수들은 
setup()
 단계에서 센서의 종류와 핀 연결을 정의합니다.

setTypeRC() / setTypeAnalog()
기능: 센서의 읽기 방식을 설정합니다.
RC (Resistor-Capacitor): 디지털 핀을 사용하여 커패시터가 방전되는 시간을 측정합니다. (QTR-8RC 등)
Analog: 아날로그 핀을 사용하여 전압(ADC 값)을 측정합니다. (QTR-8A 등)
사용 예: qtr.setTypeRC();
setSensorPins(const uint8_t * pins, uint8_t sensorCount)
기능: 센서가 연결된 아두이노 핀 번호들의 배열과 센서의 개수를 설정합니다.
인자:
pins: 핀 번호가 담긴 배열 (예: {28, 29, ...})
sensorCount: 센서의 총 개수 (예: 8)
사용 예: qtr.setSensorPins(sensorPins, SensorCount);
setEmitterPin(uint8_t pin)
기능: 센서의 적외선(IR) LED(Emitter)를 켜고 끄는 제어 핀을 설정합니다.
특징:
유효한 핀 번호를 넣으면 센서 값을 읽을 때만 LED를 켜서 배터리를 절약할 수 있습니다.
255나 QTR_NO_EMITTER_PIN을 넣으면 제어하지 않음(항상 켜져 있거나 별도 전원 연결)을 의미합니다.
사용 예: qtr.setEmitterPin(255);
2. 센서 보정 (Calibration)
센서마다 감도가 다르고, 바닥(흰색/검은색)의 반사율이 환경마다 다르기 때문에 보정 과정이 필수적입니다.

calibrate()
기능: 현재 센서가 보고 있는 값을 읽어서, 내부적으로 최솟값(Min)과 최댓값(Max)을 기록합니다.
동작: 
loop()
 등에서 약 10초간 반복 호출하며 로봇을 좌우로 흔들어주면, 센서가 경험한 가장 밝은 값(흰색)과 가장 어두운 값(검은색)을 학습합니다.
사용 예:
cpp
for (int i = 0; i < 400; i++) {
  qtr.calibrate(); // 내부 변수 calibrationOn.minimum/maximum 갱신
}
calibrationOn (구조체 멤버)
기능: 캘리브레이션 결과가 저장되는 공개(Public) 구조체입니다.
하위 멤버:
minimum: 각 센서별 학습된 최솟값 배열
maximum: 각 센서별 학습된 최댓값 배열
사용 예: 디버깅 시 qtr.calibrationOn.minimum[i]를 출력하여 보정 상태 확인.
3. 센서 값 읽기 (Reading Values)
read(uint16_t * sensorValues)
기능: 센서의 Raw 값(가공되지 않은 원본 시간/전압 값)을 읽어 배열에 저장합니다. 보정이 적용되지 않습니다.
readCalibrated(uint16_t * sensorValues)
기능: calibrate()로 학습된 Min/Max 값을 바탕으로, 현재 값을 0 ~ 1000 사이로 정규화하여 반환합니다.
범위:
0에 가까움: 보정된 최솟값(흰색에 가까움)
1000에 가까움: 보정된 최댓값(검은색에 가까움)
장점: 환경이 바뀌어도 0~1000이라는 통일된 기준을 사용할 수 있습니다.
4. 라인 위치 추적 (Line Position) - 핵심 기능
PID 제어의 입력값(Input)이 되는 라인의 위치를 계산합니다.

readLineBlack(uint16_t * sensorValues)
기능: 검은색 라인을 따라가도록 설계된 위치 계산 함수입니다. (바닥이 흰색, 라인이 검은색일 때)
출력 범위: 0 ~ 
(센서 수 - 1) * 1000
예: 8개 센서 사용 시 0 ~ 7000
0: 가장 왼쪽 센서(0번) 아래에 라인이 있음
3500: 정중앙에 라인이 있음
7000: 가장 오른쪽 센서(7번) 아래에 라인이 있음
알고리즘: 가중 평균(Weighted Average) 방식을 사용하여, 센서 2~3개에 걸쳐 있는 라인의 위치를 매우 정밀하게 추정합니다.
사용 예: uint16_t position = qtr.readLineBlack(sensorValues);
readLineWhite(uint16_t * sensorValues)
기능: readLineBlack과 반대로, 검은 바닥에 흰색 라인을 추적할 때 사용합니다.
요약 (QTR_Test.ino 기준)
초기화: setTypeRC와 setSensorPins로 디지털 핀 8개를 설정합니다.
보정: calibrate를 250회 반복하며 흰색/검은색 기준점을 잡습니다.
실행: readLineBlack을 통해 0 ~ 7000 사이의 정밀한 라인 위치값을 얻어내고, 이를 통해 로봇이 라인 중심(3500)에서 얼마나 벗어났는지(에러)를 계산할 수 있게 해줍니다.
Good
Bad
