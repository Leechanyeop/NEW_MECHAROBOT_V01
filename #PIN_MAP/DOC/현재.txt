현재 
ESP32_Master.ino
는 로봇의 두뇌 역할을 하며, 상위 시스템(PC/Modbus)과 하위 구동부(Arduino Mega) 사이를 연결하는 통신 게이트웨이이자 내비게이션 장치입니다.

주요 기능을 4가지 핵심 파트로 나누어 설명해 드리겠습니다.

1. 엔코더 수집 및 노이즈 필터링 (ISR 파트)
ESP32가 바퀴의 회전수(Pulse)를 직접 읽는 부분입니다.

이중 체크 필터: digitalRead를 수행한 뒤 ets_delay_us(5)(5마이크로초) 대기 후 다시 한번 읽습니다. 이는 전기적 노이즈로 인한 가짜 신호(Ghost Pulse)를 걸러내어, 로봇이 가만히 있는데 좌표가 올라가는 현상을 방지합니다.
CHANGE 인터럽트: 신호의 상승과 하강을 모두 체크하여 해상도를 2배로 높였습니다. (11펄스 × 2 × 30감속비 = 바퀴 한 바퀴당 660틱)
2. 오도메트리 좌표 계산 (Odometry 파트)
수집한 틱 데이터를 기반으로 로봇의 현재 위치(X, Y, Theta)를 계산합니다.

수학 모델: 차동 주행(Differential Drive) 방식의 기구학 모델을 사용하여, 양쪽 바퀴의 이동 거리 차이로 직진 거리(dS)와 회전 각도(dT)를 도출합니다.
단위 변환: 내부적으로는 mm 단위를 사용하지만, 상위 시스템으로 보낼 때는 PLC 표준에 맞춰 m(미터) 단위로 변환합니다.
3. Modbus TCP 통신 (상위 통신 파트)
PC에 있는 Modbus 서버로 데이터를 쏘는 핵심 로직입니다.

수동 패킷 빌딩 (Binary): 라이브러리를 쓰지 않고 직접 16진수 패킷(frame[])을 조립합니다. 이는 속도가 매우 빠르고 메모리 점유가 적습니다.
태그 맵 연동 (FC 16): 이미지로 보내주신 주소 체계에 맞춰 전송합니다.
40001~40002: X, Y 좌표 (Float 또는 정수 포맷)
40003: State (로봇 작동 여부)
40004: To (현재 가고 있는 목표 경로)
Keep-Alive: 서버와의 연결이 끊어지면 3초마다 자동으로 재접속을 시도합니다.

4. SPI 릴레이 및 특수 모드 (하위 제어 파트)
Arduino Mega 보드에 명령을 내리는 부분입니다.

<CMD> 프로토콜: 메가 보드와의 약속된 규격인 < + 명령어 + > 형식으로 데이터를 보냅니다.
10회전 자동 주행 (Mode 1): 서버에서 '1'을 받으면 현재 위치로부터 정확하게 6600틱(10바퀴)이 될 때까지 전진 명령(w)을 내리고, 도달하면 자동으로 정지 명령(x)을 보냅니다.
하트비트: 매 0.5초마다 메가 보드에 신호를 보내어 통신이 살아있음을 알립니다.
코드의 전체 흐름 요약:
부팅: WiFi 연결 및 시리얼 모니터에 로컬 IP 출력.
루프 시작:
네트워크 상태 체크 (끊기면 재연결).
0.5초 주기: 오도메트리 계산 → Modbus 패킷 조립 → PC로 전송.
입력 대기: 서버(Modbus)나 시리얼 모니터에서 명령이 오면 가공해서 Mega로 전달.
실시간 감시: 10회전 모드 주행 중이면 목표치에 달성했는지 체크하여 자동 정지.
이 코드는 산업 현장에서 사용하는 AGV/AMR 컨트롤러의 표준 구조를 따르고 있어, 향후 다른 상위 시스템(C#, Python, PLC 등)과 연동하기 매우 유리한 구조입니다.