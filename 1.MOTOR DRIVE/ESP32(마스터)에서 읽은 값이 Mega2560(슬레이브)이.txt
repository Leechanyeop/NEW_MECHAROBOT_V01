ESP32(마스터)에서 읽은 값이 Mega2560(슬레이브)이 보낸 값과 다르게 나오는 이유는 바이트 순서(엔디언)·비트 오더(MSBFIRST/LSBFIRST)·전송 타이밍(슬레이브가 SPDR에 보낼 바이트를 준비하는 시점) 중 하나 또는 복합적인 문제 때문입니다. 그 결과 바이트들이 잘못된 순서로 재조합되거나 부호가 뒤바뀌어 음수로 보이게 됩니다.

문제별 상세 설명
1. 바이트 순서(엔디언)와 부호
- union { long val; byte b[4]; }에서 data.b[0]이 어떤 자리(LSB 또는 MSB)를 의미하는지는 플랫폼과 설계에 따라 달라집니다.
- ESP32와 Mega 모두 리틀엔디언이지만 SPI로 전송되는 바이트 순서(슬레이브가 먼저 내보내는 바이트가 LSB인지 MSB인지)와 마스터가 재조합하는 방식이 일치하지 않으면 값이 엉뚱하게 나옵니다.
- 또한 long이 signed 타입이므로 바이트가 뒤바뀌면 최상위 비트가 1로 해석되어 음수로 보일 수 있습니다.
2. SPI 비트 오더 (MSBFIRST / LSBFIRST)
- SPI는 바이트 내에서 비트 전송 순서도 설정 가능합니다. 슬레이브가 MSB-first로 보낼 때 마스터가 LSBFIRST로 읽으면 한 바이트 자체가 뒤집혀 잘못된 값이 됩니다.
- Arduino SPI.transfer 기본은 MSBFIRST지만 설정이 다르면 문제가 생깁니다.
3. 슬레이브의 전송 준비 타이밍 (SPDR 준비 시점)
- AVR(Slave)에서 SPDR = data.b[idx];만 써놓는다고 해서 그 바이트가 즉시 마스터로 전송되는 것은 아닙니다. 마스터가 클럭을 발생시켜야 실제로 MISO로 시프트됩니다.
- 슬레이브는 보통 **SPI 인터럽트(SPI_STC_vect)**에서 다음 바이트를 SPDR에 채워 넣어야 마스터가 연속으로 클럭을 보낼 때 올바른 바이트가 나갑니다.
- 만약 SPDR에 바이트를 채우는 시점이 마스터가 클럭을 돌리는 시점과 맞지 않으면 마스터는 이전/쓰레기 바이트를 읽게 됩니다.
4. CS(Chip Select) 관리
- CS가 내려질 때(LOW)부터 올릴 때(HIGH)까지의 구간을 하나의 트랜잭션으로 보고 idx를 0으로 리셋해야 합니다. CS가 풀린 상태에서 idx가 계속 증가하면 마스터가 읽는 4바이트가 슬라이드되어 엉뚱한 값이 됩니다.
5. 원자성(atomic) 및 동시 접근
- 슬레이브에서 encoderPos가 인터럽트나 다른 코드에서 변경될 수 있다면, 4바이트를 읽어 data.val에 넣는 과정이 원자적이어야 합니다. 그렇지 않으면 바이트들이 서로 다른 시점의 값으로 섞일 수 있습니다.

디버깅 체크리스트 (우선순위)
- 슬레이브와 마스터의 SPI 설정 일치: SPISettings(clock, MSBFIRST/LSBFIRST, SPI_MODE0/1/2/3)를 동일하게 맞춤.
- CS 동작 확인: CS가 LOW로 내려질 때마다 idx = 0;으로 초기화.
- 슬레이브가 SPDR을 적절한 시점에 채우는지 확인: SPI 인터럽트 방식으로 다음 바이트를 준비하도록 구현.
- 수신 바이트를 개별적으로 출력: 마스터에서 각 data.b[i]를 Serial.print(..., HEX)로 찍어 실제 전송 순서를 확인.
- 타입과 부호 명확화: uint32_t 사용 권장(부호 문제 제거).
- 하드웨어 점검: GND 공통, MISO/MOSI/SCK/CS 배선 확인, 풀업/풀다운 필요 여부 확인.
- 로직 분석기 사용: 가능하면 로직 아날라이저로 SCK/MOSI/MISO/CS를 캡처해 실제 비트/바이트 순서를 확인.
